package crd

import (
	"reflect"

	apiextv1beta1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"
	apiextcs "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/client-go/rest"
)

const (
	Plural      = "solrs"
	Group       = "skpr.io"
	Version     = "v1"
	FullCRDName = "solrs.skpr.io"
)

// Create the CRD resource, ignore error if it already exists
func Create(clientset apiextcs.Interface) error {
	definition := &apiextv1beta1.CustomResourceDefinition{
		ObjectMeta: meta_v1.ObjectMeta{
			Name: FullCRDName,
		},
		Spec: apiextv1beta1.CustomResourceDefinitionSpec{
			Group:   Group,
			Version: Version,
			Scope:   apiextv1beta1.NamespaceScoped,
			Names: apiextv1beta1.CustomResourceDefinitionNames{
				Plural: Plural,
				Kind:   reflect.TypeOf(Solr{}).Name(),
			},
		},
	}

	_, err := clientset.ApiextensionsV1beta1().CustomResourceDefinitions().Create(definition)
	if err != nil && apierrors.IsAlreadyExists(err) {
		return nil
	}

	return err
}

func Client(cfg *rest.Config) (*rest.RESTClient, *runtime.Scheme, error) {
	var (
		scheme        = runtime.NewScheme()
		SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)
	)

	err := SchemeBuilder.AddToScheme(scheme)
	if err != nil {
		return nil, nil, err
	}

	config := *cfg
	config.GroupVersion = &SchemeGroupVersion
	config.APIPath = "/apis"
	config.ContentType = runtime.ContentTypeJSON
	config.NegotiatedSerializer = serializer.DirectCodecFactory{
		CodecFactory: serializer.NewCodecFactory(scheme),
	}

	client, err := rest.RESTClientFor(&config)
	if err != nil {
		return nil, nil, err
	}

	return client, scheme, nil
}

// Solr is a meta class which will be used to provision a Solr instance.
type Solr struct {
	meta_v1.TypeMeta   `json:",inline"`
	meta_v1.ObjectMeta `json:"metadata"`
	Spec               SolrSpec `json:"spec"`
}

// SolrSpecSize allows us to specify instance sizing in a simple format.
type SolrSpecSize string

const (
	// SolrSpecSizeSmall is for dev / stg deployments.
	SolrSpecSizeSmall SolrSpecSize = "small"
	// SolrSpecSizeMedium is for small production deployments.
	SolrSpecSizeMedium SolrSpecSize = "medium"
	// SolrSpecSizeLarge is for large production deployments.
	SolrSpecSizeLarge SolrSpecSize = "large"
)

// SolrSpec is what we are provisioning.
type SolrSpec struct {
	Version   string       `json:"version"`
	ConfigMap string       `json:"configMap"`
	Size      SolrSpecSize `json:"size"`
}

// SolrList is a list of all our Solr instances.
type SolrList struct {
	meta_v1.TypeMeta `json:",inline"`
	meta_v1.ListMeta `json:"metadata"`
	Items            []*Solr `json:"items"`
}

var SchemeGroupVersion = schema.GroupVersion{
	Group:   Group,
	Version: Version,
}

func addKnownTypes(scheme *runtime.Scheme) error {
	scheme.AddKnownTypes(SchemeGroupVersion,
		&Solr{},
		&SolrList{},
	)

	meta_v1.AddToGroupVersion(scheme, SchemeGroupVersion)

	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Solr) DeepCopyInto(out *Solr) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Solr.
func (in *Solr) DeepCopy() *Solr {
	if in == nil {
		return nil
	}
	out := new(Solr)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Solr) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}

	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SolrList) DeepCopyInto(out *SolrList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	out.ListMeta = in.ListMeta
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]*Solr, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto((*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SolrList.
func (in *SolrList) DeepCopy() *SolrList {
	if in == nil {
		return nil
	}
	out := new(SolrList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SolrList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}

	return nil
}
